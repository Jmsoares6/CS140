        +---------------------------+
        | CS 140                    |
        | PROJECT 3: VIRTUAL MEMORY |
        |  DESIGN DOCUMENT          |
        +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Song Han <songhan@stanford.edu>
Jinchao Ye <jcye@stanford.edu>
Bo Wang <bowang@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

FirstName LastName: contribution
FirstName LastName: contribution
FirstName LastName: contribution

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

      PAGE TABLE MANAGEMENT
      =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* spte_flags is used to denote the kind of a page, memory mapped file, code, 
   initialized data or uninitialized data */
enum spte_flags
{
  SPTE_M  = 0x1,   /* 1 if memory mapped file */
  SPTE_C  = 0x2,   /* 1 if executable's code segment */
  SPTE_DI = 0x4,   /* 1 if initialized data */
  SPTE_DU = 0x8    /* 1 if uninitialized data */
};

/* Supplemental page table entry, used for each page of memory mapped file
   and code, also data before it has ever been loaded */
struct suppl_pte
{
  uint32_t *pte;                  /* Kernel virtual address to 
                                     the page table entry */
  struct file *file;              /* File this page is mapped to */
  enum spte_flags flags;          /* Types of the page */
  bool writable;                  /* Whether this page is writable */
  off_t offset;                   /* Offset in the file the page is mapped to */
  size_t bytes_read;              /* Number of bytes read from the file */
  struct hash_elem elem_hash;     /* Element for supplemental page table */
};

/* each thread has a supplementary page table with a lock */
struct thread
{
  ...
  struct hash suppl_pt;              /* Supplemental page table */
  struct lock spt_lock;              /* Supplemental page table lock */
  ...
}

#define PTE_FLAGS 0x00000fff    /* Flag bits. */
#define PTE_ADDR  0xfffff000    /* Address bits. */
#define PTE_AVL   0x00000e00    /* Bits available for OS use. */
#define PTE_P 0x1               /* 1=present, 0=not present. */
#define PTE_W 0x2               /* 1=read/write, 0=read-only. */
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_M 0x8               /* 1=memory mapped file, 0=normal memory */
#define PTE_S 0x10              /* 1=shared memory, 0=not shared */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */
#define PTE_I 0x80              /* 1=pinned, 0=not pinned */
#define MAX_SWAP_PAGE_NO 0xfffff

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

Given the user virtual address of a page, we first look up the page in the 
page directory of current thread. No matter what kind a page is, there is always
a corresponding page table entry unless we are referring to an nonexistent page.

Once we get the page table entry (PTE for short), we check whether it is present
by the PTE_P bit. If it is present, then it is in memory and we can get the 
physical address of the frame by the top 20 bits in the PTE (the low 12 bits of
a frame address are always 0). 
If it is not present and PTE_M bit is 1, then it is in memory mapped file. We 
use the pointer to PTE as the key to look up the corresponding supplementary 
page table entry (SPTE for short). We can locate the frame via the file pointer 
and offset.
If it is not present and PTE_M bit is 0 and the top 20 bits of PTE is not 0,
then it is in swap. We can get the swap frame number from the top 20 bits of
PTE (a frame is 8 sectors here). Then we can easily locate the frame in the swap
using this swap frame number.
If it is not present and PTE_M is 0 and the top 20 bits of PTE is also 0, this 
means such page doens't exist. In this case, just exit(-1). 

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid this issue by only accessing user data through user virtual addresses 
(only through user threads' page table entries). Also, whenever we changes a
PTE, we flush the TLB to ensure consistency.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

We change the original bitmap to our frame table.

struct frame_table
{
  size_t page_cnt;
  uint32_t **frames;
  size_t clock_cur;
};

Here each frame table entry stores a pointer to
1)  page table entry if the page is present or in swap
or  
2)  supplementary page table entry if the page is in file

When we allocate a page, we will scan the frame table to get a new frame. We 
will call palloc_get_page(). It will then call palloc_get_multiple() if there 
are free frames, or page_out_then_get_page() if there is no free frame. Both 
functions have to acquire pool->lock before they can scan the frames or do clock
algorithm to get a frame. Therefore one process have to wait till the other 
process get a frame before it can search for a new frame.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

All pages that are currently in memory can be located by page table entries as 
in project 2.

All pages that are in swap can also be located by page table entries. The 
address of each allocated swap frame is stored as the top 20 bits in 
corresponding page table entry (where physical address was stored when this page
was in memory). Therefore, we don't even need to lookup in supplementary page 
table. We only need the top 20 bits in the PTE to locate the frame in swap.
Comparing with creating a supplementary page table entry for a swap page, this 
method saves both time and space.

All pages that are in file (memory mapped file, code or data) can be located 
by supplementary page table entries. We choose to use hashtable to implement our 
supplementary page table because insertion, deletion and lookup only need O(1) 
time in hashtable. Therefore, we can do virtual-to-physical mappings very 
efficiently.  

           PAGING TO AND FROM DISK
           =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* global frame table, frames stores pointers to PTE or SPTE, clock_cur is used
   in clock algorithm */
struct frame_table
{
  size_t page_cnt;
  uint32_t **frames;
  size_t clock_cur;
};

/* global swap table to track the usage of each sector in swap */
struct swap_table
  {
    struct block *swap_block;  /* Swap block used for swap table on the disk */
    struct bitmap *bitmap;     /* Bitmap keeps track of allocation status */
    struct lock lock;          /* Lock to synchronize access to swap table */
  };

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We use clock algorithm to choose a frame to evict. As shown in B1, we have a 
clock "hand" clock_cur defined in the struct frame_table. Whenever we need to 
choose a frame to evict, the "hand" clock_cur scans through the frames in the 
frame_table. Since we don't implement sharing, there is only 1 corresponding PTE
in user memory for each frame. In our design, frames store the pointers to PTEs
or SPTEs, and each SPTE also has a PTE pointer in it. Therefore, we can access
each frame's corresponding PTE. 

We first check PTE_I bit of the corresponding PTE. If it is 1, then it means
that the corresponding frame is being swapped out or written to file. Therefore
we increment the "hand" clock_cur and continue to search.

Else if the PTE_A bit of the corresponding PTE is 1, it means that this frame 
has recently been visited recently. In this case, we reset the PTE_A bit, flush 
TLB, increment the "hand" clock_cur and continue to search.

Else then the PTE_A bit of the corresponding PTE is 0, it means that this frame
hasn't been visited in the last cycle. We then will choose this frame to evict!

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

In our design, a frame table entry stores pointer to
1)  corresponding page table entry if the page is present or in swap
or  
2)  corresponding supplementary page table entry if the frame is in file

WHen a process P obatains a frame that was previously used by a process Q, it 
will first clear the PTE_P bit in the Q's PTE corresponding to the frame, write
it to swap or file. If it is write to swap, the swap_frame_no is stored in the 
top 20 bits in the PTE. If it is write to file, then find the position according
to the file pointer and offset in the corresponding SPTE. 

The frame table entry originally pointed to Q's PTE (if the old page was not 
memory mapped file) or SPTE (if the old page was memory mapped file). We then 
make the frame table entry point to P's corresponding PTE (if the new page is 
not memory mapped file) or SPTE (if the new page is memory mapped file). By 
changing the content of the frame table entry, we refect Q no longer has the 
frame and P has it.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

       MEMORY MAPPED FILES
       ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
{
  ...
  struct hash mmap_files;            /* Hashtable of memory mapped files */
  int mmap_files_num_ever;           /* # of files ever mapped, used as key */
  ...
}
We store information about memory mapped files as a hashtable "mmap_files" in 
each thread. "mmap_files_num_ever" is used as a key inthis hashtable.

/* Memory mapped file */
struct mmap_file
{
  int mid;
  struct file *file;                  /* File the memory is mapped to */
  uint8_t *upage;                     /* User virtual address of the first
                                         mapping page */
  size_t num_pages;                   /* Number of pages mapped to the file */
  struct hash_elem elem;
};
We keep id, file pointer, starting user virtual address and number of pages in 
this struct.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

The hashtable "mmap_files" is initialized when a process starts. Once a user
process maps a file to memory, pintos will populate page table and supplementary 
page table according to the information of the file to be mapped. When some 
process queries to the mapped data, it will cause a page fault and actually 
load the corresponding page. When the process unmaps the file, pintos will free
corresponding frames and supplementary page table entries and clear page table
entries. For every mapped page, if the page is dirty, write it back to the file.
When a process terminates, unmap all of its memory mapped files.

In page fault handler, there are 4 cases:
The first case is that the fault page is for stack growth. This is checked by 
comparing the fault address with stack pointer. In this case, we call 
stack_growth() to allocate a new frame. 
The second case is that the fault page should be loaded from swap. The page 
content might be data, stack, etc, but not memory mapped file. We call 
load_page_from_swap() in this case.
The third case is that the fault page should be loaded from memory mapped file. 
Since memory mapped file use itself as backing store, We will call 
load_page_from_file() in this case. We use PET_M bit and present bit in PTE to
see whether the page should be loaded from memory mapped file.
The fourth case is none of the above. We simply call _exit(-1) here.

The eviction algorithm is implemented in page_out_then_get_page() in palloc.c.
If the page should be evicted is a memory mapped file page, then write it back
to the file. If the page should be evicted to swap, then write it to swap.
Another difference is that when a swap page is evicted, we record the 
swap_frame_no in corresponding PTE, while for memory mapped file, the offset 
and file pointer are already stored in corresponding supplementary page table 
entry.


>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

We calculate how many pages the mapping needs by round up file_length/PGSIZE. 
Then for each of the pages (the first page starts at the virtual address 
provided by the user), we call lookup_page(t->pagedir, page addr, false) 
to see whether there is a corresponding PTE for this page address in the page 
directory of current thread. If there is, this means an overlap and MAP_FAILED
is returned. 


---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

In our spte_flag in supplementary page table entries, there are 4 kinds:
enum spte_flags
{
  SPTE_M  = 0x1,   /* 1 if memory mapped file */
  SPTE_C  = 0x2,   /* 1 if executable's code segment */
  SPTE_DI = 0x4,   /* 1 if initialized data */
  SPTE_DU = 0x8    /* 1 if uninitialized data */
};

When memory mapped file pages trigger page fault, our pintos will call 
load_page_from_file(). 

We treat memory mapped files and code as the same in the page_fault handler and
the eviction process. We have a bit PTE_M in PTE to denote whether the page is 
memory mapped. Because once loaded, the memory mapped file pages and code pages 
both set their PTE_M bit in their PTEs to be 1. We haven't seen any disadvantage
for sharing code for these two kinds of pages.

Their are two kinds of data, initialized data and uninitialized data. When we 
load segment lazily, we add PTEs with PET_M set to 1 to page directory for them.
For the first time of page fault, they are treated as memory mapped files, 
except uninitialized data is set as 0 instead of being loaded from file. After
they are loaded for the first time, we set the PTE_M bit in their PTEs to be 0.
Then they will be swapped between memory and swap afterwards. The data pages do
not share much code with memory mapped files because they mainly interact with 
swap once they are loaded from executables.

         SURVEY QUESTIONS
         ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?